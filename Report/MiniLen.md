# 集合论实验报告：最短路径
## 一·实验背景
### 1.实验目的
在实际生活中，我们常常会遇到需要这样的问题，比如：

- 一批货从北京到武汉的的最快，或最省钱的走法。
- 在城市群中建一个仓储基地，建在什么位置可以让各个城市的送货速度都比较快。

实验目标就是解决诸如上述的各类问题。
### 2.实验描述
诸如以上问题，我们都可以将其转化为图论中的最短路径问题。
将以上问题可以抽象为如下情形:

![Graph](https://github.com/AlongWY/Graph/raw/master/Report/Pics/MiniLen.png)

~~~mermaid
graph LR
北京 ---|10| 石家庄
北京 ---|20| 太原
石家庄 ---|20| 郑州
石家庄 ---|10| 济南
济南 ---|15| 郑州
太原 --- |20| 郑州
郑州 ---|11| 合肥
合肥 ---|10| 武汉
太原 ---|30| 西安
西安 ---|15| 武汉
~~~



将各个位置考虑为图的顶点，而距离或者所用时间则考虑为图的边权。
则可以利用最短路径算法求解。
此处采用迪杰斯特拉算法。

## 二·实验原理
### 1.迪杰斯特拉算法思想
* 设G=(V,E)是一个带权有向图，把图中顶点集合V分成两组:
    1. 第一组为已求出最短路径的顶点集合（用S表示) 
    2. 第二组为其余未确定最短路径的顶点集合（用U表示）
* 初始时S中只有一个源点，以后每求得一条最短路径 , 就将加入到集合S中，直到全部顶点都加入到S中，算法就结束了。
* 按最短路径长度的递增次序依次把第二组的顶点加入S中。在加入的过程中，总保持从源点v到S中各顶点的最短路径长度不大于从源点v到U中任何顶点的最短路径长度。
* 此外，每个顶点对应一个距离，S中的顶点的距离就是从v到此顶点的最短路径长度，U中的顶点的距离，是从v到此顶点只包括S中的顶点为中间顶点的当前最短路径长度。

### 2.迪杰斯特拉算法步骤
1. 初始时，S只包含源点，即S＝{v}，v的距离为0。U包含除v外的其他顶点，即:U={其余顶点}，若v与U中顶点u有边，则<u,v>正常有权值，若u不是v的出边邻接点，则<u,v>权值为∞。
2. 从U中选取一个距离v最小的顶点k，把k，加入S中（该选定的距离就是v到k的最短路径长度）。
3. 以k为新考虑的中间点，修改U中各顶点的距离；若从源点v到顶点u的距离（经过顶点k）比原来距离（不经过顶点k）短，则修改顶点u的距离值，修改后的距离值的顶点k的距离加上边上的权。
4. 重复步骤2和3直到所有顶点都包含在S中。

![例图](https://github.com/AlongWY/Graph/raw/master/Report/Pics/Dijkstra.gif)

## 三·代码实现
1. 设计数据结构

![数据结构图]()

~~~c
//无向带权图数据结构
typedef struct _list {
    int vec;                        //临接顶点
    int weight;                     //权
} link_list;

typedef struct w_graph {
    int n;                          //顶点个数
    int m;                          //边个数
    struct successors {
        int d;                      //临接点个数
        int len;                    //最大临接点个数
        char is_sorted;             //
        link_list list[1];          //临接列表
    } *v_list[1];
} *WGraph;
~~~

2. 实现算法

## 四·实验结果
## 五·参考资料
